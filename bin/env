#!/bin/sh

#
# Generates .env.sh

set -eu

cd "$(dirname "$0")/.."

#
# Force creation of .env.sh
: "${ENV_FORCE=0}"

# TODO: FaltarÃ­a el SH y las variables de system.sh y probarlo un poco y los comandos de alias

create_dirs_and_files() {
  for _gen_env_dir in ${ENV_SUPPORTED}; do
    find "${ENV_GENERATED}" -mindepth 1 -maxdepth 1 -type d | while read -r _gen_env_dir_generated; do
      _gen_env_dir_generated_absolute="${_gen_env_dir_generated}/${_gen_env_dir}"
        case "${_gen_env_dir}" in
          rhel|rhel_fedora)
            cd "${_gen_env_dir_generated}"
            if [ "${_gen_env_dir_generated##*/}" = rc.d ]; then
             ! test -e "${_gen_env_dir}" || rm -r "${_gen_env_dir}"
             ln -s fedora "${_gen_env_dir}"
            else
             ! test -e "${_gen_env_dir}.sh" || rm -r "${_gen_env_dir}.sh"
             ln -s fedora.sh "${_gen_env_dir}.sh"
            fi
            ;;
          *)
            if [ "${_gen_env_dir_generated##*/}" = rc.d ]; then
              mkdir -p "${_gen_env_dir_generated_absolute}"
              touch "${_gen_env_dir_generated_absolute}/dirs.sh"
              touch "${_gen_env_dir_generated_absolute}/sudo.sh"
            else
              touch "${_gen_env_dir_generated_absolute}.sh"
            fi
            ;;
        esac
    done

    { find "${ENV_ETC}" -mindepth 2 -maxdepth 2 -type d \
      -not \( -path "${ENV_ETC_COMPLETION}/*" -or -path "${ENV_ETC_FUNCTIONS}/*" \); \
      echo "${ENV_ETC_FUNCTIONS}"; } | while read -r _gen_env_dir_etc; do
        _gen_env_dir_etc_absolute="${_gen_env_dir_etc}/${_gen_env_dir}"
        case "${_gen_env_dir}" in
          rhel|rhel_fedora)
            cd "${_gen_env_dir_etc}"
            ! test -e "${_gen_env_dir}" || rm -r "${_gen_env_dir}"
            ln -s fedora "${_gen_env_dir}"
            ;;
          *)
            mkdir -p "${_gen_env_dir_etc_absolute}"
            if [ "${_gen_env_dir_etc##*/}" = hooks.d ]; then
              for _gen_env_dir_etc_shell in sh bash bash-4 zsh; do
                _gen_env_dir_etc_absolute="${_gen_env_dir_etc}/${_gen_env_dir}/${_gen_env_dir_etc_shell}"
                case "${_gen_env_dir}" in
                  rhel|rhel_fedora) : ;;
                  *)
                    mkdir -p "${_gen_env_dir_etc_absolute}"
                    touch "${_gen_env_dir_etc_absolute}/.gitkeep"
                    ;;
                esac
              done
            else
              touch "${_gen_env_dir_etc_absolute}/.gitkeep"
            fi
            ;;
        esac
    done
  done

  for _gen_env_dir_home in profile.d rc.d; do
    _gen_env_dir_home_absolute="${ENV_CUSTOM}/${_gen_env_dir_home}"
    if ! test -f "${_gen_env_dir_home_absolute}/.gitkeep"; then
      mkdir -p "${_gen_env_dir_home_absolute}"
      touch "${_gen_env_dir_home_absolute}/.gitkeep"
    fi
  done
}

echo_files_to_source() {
  find "$1" -type f \
    \( \
      -path "*/00-common/*" \
      -or -path "*/${HOSTNAME}/*" \
      -or -path "*/${ID_LIKE}/*" \
      -or -path "*/${UNAME}/*" \
      -or -name "00-common.*" \
      -or -name "${HOSTNAME}.*" \
      -or -name "${ID_LIKE}.*" \
      -or -name "${UNAME}.*" \
    \) \
    -exec echo "  ${2-}. \"{}\"" \; | sort -n
}

find_dirs_to_source() {
  find "$1" -mindepth "$2" -maxdepth "$2" -type d \
    \( \
      -path "*/00-common/*" \
      -or -path "*/${HOSTNAME}/*" \
      -or -path "*/${ID_LIKE}/*" \
      -or -path "*/${UNAME}/*" \
      -or -name "00-common" \
      -or -name "${HOSTNAME}" \
      -or -name "${ID_LIKE}" \
      -or -name "${UNAME}" \
    \) | sort -n
}

hooks() {
  find_dirs_to_source "${1}" 3 | grep -E "/sh$|/${SH:-bash}$" | while read -r i; do
    echo "  env_source_dir \"${i}\""
  done
}

hooks_no() {
  find_dirs_to_source "$1" 2 | grep -v "/hooks.d/" | while read -r i; do echo "  env_source_dir_no \"${i}\""; done
}

write_functions() {
  cat > "${_ENV_TMP}" <<EOF
# shellcheck shell=sh

#
# System wide POSIX profile
# Generated by $0

unset ENV

if ! command -v reenv >/dev/null; then
  . "${ENV_ETC_FUNCTIONS}/env.sh"

$(find_dirs_to_source "${ENV_ETC_FUNCTIONS}" 1 | while read -r i; do echo "  env_source_dir \"${i}\""; done)
fi
EOF
}

write_profile() {
  cat >> "${_ENV_TMP}" <<EOF

if ! echo "\${PATH}" | grep -q "${ENV_TOP}/bin:"; then
  export PATH="${ENV_TOP}/bin:\${PATH}"
  : "\${HOSTNAME=\$(hostname)}"; export HOSTNAME

$(for var in ENV_CUSTOM ENV_ETC ENV_GENERATED ENV_SUPPORTED ENV_TOP \
  ID_LIKE MACOS SUDO UNAME VGA; do
  echo "  export ${var}=\"$(eval echo "\$${var}")\""
done)

$(hooks_no "${ENV_ETC_PROFILE_D}")

$(hooks "${ENV_ETC_PROFILE_D}")

$(echo_files_to_source "${ENV_GENERATED_PROFILE_D}")
fi
EOF
}

write_rc() {
  cat >> "${_ENV_TMP}" <<EOF

#
# RC for interactive shells has been sourced already
: "\${ENV_SOURCED=0}"

if { [ "\${PS1-}" ] || echo "\$-" | grep -q i; } && [ "\${ENV_SOURCED}" -eq 0 ]; then
  ENV_SOURCED=1

  unalias cp egrep fgrep grep l l. la ll lld ls mv rm xzegrep xzfgrep xzgrep zegrep zfgrep zgrep 2>/dev/null

$(hooks_no "${ENV_ETC_RC_D}")

$(hooks "${ENV_ETC_RC_D}")

$(echo_files_to_source "${ENV_GENERATED_RC_D}" | grep "/dirs.sh\"$")

  if [ "\${SUDO-}" ]; then
$(echo_files_to_source "${ENV_GENERATED_RC_D}" "  " | grep "/sudo.sh\"$")
  fi

  if has complete; then
    env_source_dir "${ENV_ETC_COMPLETION}"
  fi
fi

export ENV="${_ENV_FILE}"
EOF
}

set_vars() {
  ENV_TOP="$(pwd -P)"
  PATH="${ENV_TOP}/bin:${PATH}"

  HOSTNAME="${HOSTNAME=$(hostname)}"
  ID_LIKE="$(! test -f /etc/os-release || grep "^ID_LIKE=" /etc/os-release \
      || grep "^ID=" /etc/os-release | cut -d= -f2 | tr ' ' '_')"
  MACOS="$(if test "$(uname -s)" = "Darwin"; then echo true; else echo false; fi)"
  SUDO="$(if test -x /usr/bin/sudo; then echo /usr/bin/sudo; else echo ""; fi)"
  UNAME="$(uname -s)"
  VGA="$([ "${GITHUB_RUN_ID-}" ] || if $MACOS; then echo 1; else lspci 2>/dev/null | awk '/VGA/ { print 1 }'; fi)"

  _ENV_FILE="${ENV_TOP}/.env.sh"
  _ENV_TMP="$(mktemp)"

  ENV_CUSTOM="${ENV_TOP}/custom"
  ENV_ETC="${ENV_TOP}/etc"
  ENV_ETC_COMPLETION="${ENV_ETC}/bash_completion.d"
  ENV_ETC_FUNCTIONS="${ENV_ETC}/functions.d"
  ENV_ETC_PROFILE_D="${ENV_ETC}/profile.d"
  ENV_ETC_RC_D="${ENV_ETC}/rc.d"
  ENV_GENERATED="${ENV_TOP}/generated"
  ENV_GENERATED_PROFILE_D="${ENV_GENERATED}/profile.d"
  ENV_GENERATED_RC_D="${ENV_GENERATED}/rc.d"
  ENV_SUPPORTED="00-common arch Darwin debian fedora Linux rhel rhel_fedora ${HOSTNAME}"
}

sync() {
  if git status  | grep -q "have diverged"; then
    >&2 echo "${0##*/}: Diverged"
    exit 1
  elif git status | grep -q "Your branch is behind" && test -n "$(git status --porcelain)"; then
    >&2 echo "${0##*/}: Behind remote & directory is not clean"
    exit 1
  elif git status | grep -q "Your branch is behind"; then
    git pull --tags
    exit 0
  elif test -n "$(git status --porcelain)"; then
    git add .
    git commit -a -m "${0##*/}${1:+: ${1}}"
  fi

  ! git status | grep -q "Your branch is ahead" || git push
}

main() {
  [ "${ENV-}" ] || set_vars

  if ! test -f "${ENV:-${_ENV_FILE}}" || test "${ENV_FORCE}" -eq 1; then
    set_vars

    create_dirs_and_files

    write_functions
    write_profile
    write_rc

    mv "${_ENV_TMP}" "${_ENV_FILE}"
    sync "$@"
  fi

  for arg; do
    case "${arg}" in
      -h|--help|help) : ;;
      add|clean|del|sync) "${arg}" "$@" ;;
      hook) echo "${_ENV_FILE}" ;;
    esac
  done

}

main "$@"
