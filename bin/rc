#!/bin/sh

#
# Generates .env.sh

set -eu

cd "$(dirname "$0")/.."

#
# Force creation of .env.sh
: "${RC_FORCE=0}"

: "${RC_TRACE=0}"; [ "${RC_TRACE}" -eq 0 ] || set -x


# TODO: FaltarÃ­a el SH y las variables de system.sh y probarlo un poco y los comandos de alias

add_var() { RC_VARS="${RC_VARS:+${RC_VARS} }$1"; }

create_dirs_and_files() {
  for _gen_rc_dir in ${RC_SUPPORTED}; do
    find "${RC_GENERATED}" -mindepth 1 -maxdepth 1 -type d | while read -r _gen_rc_dir_generated; do
      _gen_rc_dir_generated_absolute="${_gen_rc_dir_generated}/${_gen_rc_dir}"
        case "${_gen_rc_dir}" in
          rhel|rhel_fedora)
            cd "${_gen_rc_dir_generated}"
            if [ "${_gen_rc_dir_generated##*/}" = rc.d ]; then
             ! test -e "${_gen_rc_dir}" || rm -r "${_gen_rc_dir}"
             ln -s fedora "${_gen_rc_dir}"
            else
             ! test -e "${_gen_rc_dir}.sh" || rm -r "${_gen_rc_dir}.sh"
             ln -s fedora.sh "${_gen_rc_dir}.sh"
            fi
            ;;
          *)
            if [ "${_gen_rc_dir_generated##*/}" = rc.d ]; then
              mkdir -p "${_gen_rc_dir_generated_absolute}"
              touch "${_gen_rc_dir_generated_absolute}/dirs.sh"
              touch "${_gen_rc_dir_generated_absolute}/sudo.sh"
            else
              touch "${_gen_rc_dir_generated_absolute}.sh"
            fi
            ;;
        esac
    done

    { find "${RC_ETC}" -mindepth 2 -maxdepth 2 -type d -not -path "${RC_ETC_FUNCTIONS}/*";
      echo "${RC_ETC_FUNCTIONS}"; } | while read -r _gen_rc_dir_etc; do
        _gen_rc_dir_etc_absolute="${_gen_rc_dir_etc}/${_gen_rc_dir}"
        case "${_gen_rc_dir}" in
          rhel|rhel_fedora)
            cd "${_gen_rc_dir_etc}"
            ! test -e "${_gen_rc_dir}" || rm -r "${_gen_rc_dir}"
            ln -s fedora "${_gen_rc_dir}"
            ;;
          *)
            mkdir -p "${_gen_rc_dir_etc_absolute}"
            if [ "${_gen_rc_dir_etc##*/}" = hooks.d ]; then
              for _gen_rc_dir_etc_shell in sh bash bash-4 zsh; do
                _gen_rc_dir_etc_absolute="${_gen_rc_dir_etc}/${_gen_rc_dir}/${_gen_rc_dir_etc_shell}"
                case "${_gen_rc_dir}" in
                  rhel|rhel_fedora) : ;;
                  *)
                    mkdir -p "${_gen_rc_dir_etc_absolute}"
                    touch "${_gen_rc_dir_etc_absolute}/.gitkeep"
                    ;;
                esac
              done
            else
              touch "${_gen_rc_dir_etc_absolute}/.gitkeep"
            fi
            ;;
        esac
    done
  done

  for _gen_rc_dir_home in completions profile.d rc.d; do
    _gen_rc_dir_home_absolute="${RC_CUSTOM}/${_gen_rc_dir_home}"
    if ! test -f "${_gen_rc_dir_home_absolute}/.gitkeep"; then
      mkdir -p "${_gen_rc_dir_home_absolute}"
      touch "${_gen_rc_dir_home_absolute}/.gitkeep"
    fi

    cd "${RC_COMPLETIONS}"
    find "../../bash_completion.d" -type f -name "*.bash" | while read -r completion; do
      rm -f "${completion##*/}"
      ln -s "${completion}" "${completion##*/}"
    done
  done
}

echo_rc_source_dir() { while read -r i; do echo "  ${1-}rc_source_dir \"${i}\""; done; }

echo_files_to_source() {
  find "$1" -type f \
    \( \
      -path "*/00-common/*" \
      -or -path "*/${HOSTNAME}/*" \
      -or -path "*/${ID_LIKE}/*" \
      -or -path "*/${UNAME}/*" \
      -or -name "00-common.*" \
      -or -name "${HOSTNAME}.*" \
      -or -name "${ID_LIKE}.*" \
      -or -name "${UNAME}.*" \
    \) \
    -exec echo "  ${2-}. \"{}\"" \; | sort -n
}

find_dirs_to_source() {
  find "$1" -mindepth "$2" -maxdepth "$2" -type d \
    \( \
      -path "*/00-common/*" \
      -or -path "*/${HOSTNAME}/*" \
      -or -path "*/${ID_LIKE}/*" \
      -or -path "*/${UNAME}/*" \
      -or -name "00-common" \
      -or -name "${HOSTNAME}" \
      -or -name "${ID_LIKE}" \
      -or -name "${UNAME}" \
    \) | sort -n
}

commands() {
    brew_bin="$(brew --prefix)/bin"
  cd "$(brew --prefix bash-completion@2)/share/bash-completion/completions"
  find "${brew_bin}" \( -type f -or -type l \) -name 'g*' | sed "s|${brew_bin}/g||g"
}


gnu_completions() {
  $MACOS || return 0

  brew_bin="$(brew --prefix)/bin"
  commands="$(find "${brew_bin}" \( -type f -or -type l \) -name 'g*' | sed "s|${brew_bin}/g||g" | grep -v "\[")"

  bash -li -c "(
    PS1='> '
    . \"$(brew --prefix)/etc/profile.d/bash_completion.sh\"
    for i in ${commands}; do
      echo \$i
      # shellcheck disable=SC3044
      complete -p \${i} 2>/dev/null | sed \"s|\${i}$|g\${i}|g\"
    done
  )" > "${RC_CUSTOM}/completions/gnu-completions.bash"

  cd "$(brew --prefix bash-completion@2)/share/bash-completion/completions"

  for command in ${commands}; do
    { test -f "${command}" && ! test -L "${command}"; } || continue
    echo rm -f "g${command}"
    echo ln -s "${command}" "g${command}"
  done
}

hooks() { find_dirs_to_source "${1}" 3 | grep -E "/sh$|/${SH:-bash}$" | echo_rc_source_dir ""; }

hooks_no() { find_dirs_to_source "$1" 2 | grep -v "/hooks.d/" | echo_rc_source_dir; }

write_compats() {
  cat >> "${_RC_TMP}" <<EOF

#
# Homebrew profile.d has been sourced already
: "\${HOMEBREW_PROFILE_D_SOURCED=0}"

if test -d "\${HOMEBREW_PREFIX}/etc/profile.d" && [ "\${HOMEBREW_PROFILE_D_SOURCED}" -eq 0 ]; then
  HOMEBREW_PROFILE_D_SOURCED=1
  rc_source_dir "\${HOMEBREW_PREFIX}/etc/profile.d"
fi
EOF
}

write_functions() {
  cat > "${_RC_TMP}" <<EOF
# shellcheck shell=sh

#
# System-wide POSIX profile
# Generated by $0

unset ENV

: "\${RC_TRACE=0}"; [ "\${RC_TRACE}" -eq 0 ] || set -x

if ! command -v resh >/dev/null; then
  . "${RC_ETC_FUNCTIONS}/${0##*/}.sh"

$(find_dirs_to_source "${RC_ETC_FUNCTIONS}" 1 | echo_rc_source_dir)
fi
EOF
}

write_profile() {
  cat >> "${_RC_TMP}" <<EOF

#
# RC: profile.d for interactive shells has been sourced already
: "\${RC_PROFILE_D_SOURCED=0}"; export RC_PROFILE_D_SOURCED

if [ "\${RC_PROFILE_D_SOURCED}" -eq 0 ]; then
  RC_PROFILE_D_SOURCED=1

$(for var in $(echo "${RC_VARS}" | tr ' ' '\n' | sort); do
  echo "  export ${var}=\"$(eval echo "\$${var}")\""
done)

  unset INFOPATH MANPATH
  if \$MACOS; then
    eval "\$(/usr/libexec/path_helper -s)"
    PATH="\$(/usr/libexec/path_helper -s):\${CLT}/usr/bin"
  else
    PATH="/home/linuxbrew/.linuxbrew/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  fi
  ! has brew || brew shellenv
  export PATH="${RC_TOP}/bin:\${PATH}"

  : "\${HOSTNAME=\$(hostname)}"; export HOSTNAME

$(hooks_no "${RC_ETC_PROFILE_D}")

$(hooks "${RC_ETC_PROFILE_D}")

$(echo_files_to_source "${RC_GENERATED_PROFILE_D}")

  rc_source_dir "${RC_CUSTOM_PROFILE_D}"
fi
EOF
}

write_rc() {
  cat >> "${_RC_TMP}" <<EOF

#
# RC: rc.d for interactive shells has been sourced already
: "\${RC_RC_D_SOURCED=0}"

if { [ "\${PS1-}" ] || echo "\$-" | grep -q i; } && [ "\${RC_RC_D_SOURCED}" -eq 0 ]; then
  RC_RC_D_SOURCED=1

  unalias cp egrep fgrep grep l l. la ll lld ls mv rm xzegrep xzfgrep xzgrep zegrep zfgrep zgrep 2>/dev/null

$(hooks_no "${RC_ETC_RC_D}")

$(hooks "${RC_ETC_RC_D}")

$(echo_files_to_source "${RC_GENERATED_RC_D}" | grep "/dirs.sh\"$")

  if [ "\${SUDO-}" ]; then
$(echo_files_to_source "${RC_GENERATED_RC_D}" "  " | grep "/sudo.sh\"$")
  fi

  rc_source_dir "${RC_CUSTOM_RC_D}"
fi

export ENV="${_RC_FILE}"

[ "\${RC_TRACE}" -eq 0 ] || set +x
EOF
}

set_vars() {
  RC_TOP="$(pwd -P)" && add_var RC_TOP
  PATH="${RC_TOP}/bin:${PATH}"

  HOSTNAME="${HOSTNAME=$(hostname)}"
  ID_LIKE="$(! test -f /etc/os-release || grep "^ID_LIKE=" /etc/os-release \
      || grep "^ID=" /etc/os-release | cut -d= -f2 | tr ' ' '_')" && add_var ID_LIKE
  MACOS="$(if test "$(uname -s)" = "Darwin"; then echo true; else echo false; fi)" && add_var MACOS
  SUDO="$(if test -x /usr/bin/sudo; then echo /usr/bin/sudo; else echo ""; fi)" && add_var SUDO
  UNAME="$(uname -s)" && add_var UNAME

  VGA=1 && add_var VGA
  if $MACOS; then
    CLT="/Library/Developer/CommandLineTools" && add_var CLT
  else
    lspci 2>/dev/null | grep -q VGA || VGA=""
  fi
  [ ! "${GITHUB_RUN_ID-}" ] || VGA=""

  _RC_FILE="${RC_TOP}/.${0##*/}.sh"
  _RC_TMP="$(mktemp)"
  RC_CUSTOM="${RC_TOP}/custom" && add_var RC_CUSTOM
  RC_CUSTOM_PROFILE_D="${RC_CUSTOM}/profile.d" && add_var RC_CUSTOM_PROFILE_D
  RC_CUSTOM_RC_D="${RC_CUSTOM}/rc.d" && add_var RC_CUSTOM_RC_D
  RC_ETC="${RC_TOP}/etc" && add_var RC_ETC
  RC_ETC_FUNCTIONS="${RC_ETC}/functions.d" && add_var RC_ETC_FUNCTIONS
  RC_ETC_PROFILE_D="${RC_ETC}/profile.d" && add_var RC_ETC_PROFILE_D
  RC_ETC_RC_D="${RC_ETC}/rc.d" && add_var RC_ETC_RC_D
  RC_GENERATED="${RC_TOP}/generated" && add_var RC_GENERATED
  RC_GENERATED_PROFILE_D="${RC_GENERATED}/profile.d" && add_var RC_GENERATED_PROFILE_D
  RC_GENERATED_RC_D="${RC_GENERATED}/rc.d" && add_var RC_GENERATED_RC_D
  RC_SUPPORTED="00-common arch Darwin debian fedora Linux rhel rhel_fedora ${HOSTNAME}" && add_var RC_SUPPORTED

  # Adds dinamically completions with __load_completion()/_completion_loader
  # /completions is added by __load_completions(
  BASH_COMPLETION_USER_DIR="${RC_CUSTOM}" && add_var BASH_COMPLETION_USER_DIR
  RC_COMPLETIONS="${RC_CUSTOM}/completions" && add_var RC_COMPLETIONS

}

sync() {
  if git status  | grep -q "have diverged"; then
    >&2 echo "${0##*/}: Diverged"
    exit 1
  elif git status | grep -q "Your branch is behind" && test -n "$(git status --porcelain)"; then
    >&2 echo "${0##*/}: Behind remote & directory is not clean"
    exit 1
  elif git status | grep -q "Your branch is behind"; then
    git pull --tags
    exit 0
  elif test -n "$(git status --porcelain)"; then
    git add .
    git commit -a -m "${0##*/}${1:+: ${1}}"
  fi

  ! git status | grep -q "Your branch is ahead" || git push
}

main() {
  [ "${ENV-}" ] || set_vars

  hook=false
  for arg; do
    case "${arg}" in
      -h|--help|help) : ;;
      --force) RC_FORCE=1  ;;
      add|clean|del|gnu|sync|gnu_completions) function="${arg}" ;;
      hook) hook=true ;;
      *) >&2 echo "${0##*/}: Unknown argument: ${arg}" ;;
    esac
  done

  [ "${RC_FORCE}" -eq 0 ] || [ ! "${function-}" ] || \
    { >&2 echo "${0##*/}: --force can not be used with ${function}"; exit 1; }

  if ! test -f "${ENV:-${_RC_FILE}}" || [ "${RC_FORCE}" -eq 1 ]; then
    # shellcheck disable=SC2010
    ls -la "${_RC_FILE}" | grep -q " ${USER} " || >&2 echo "${0##*/}: ${_RC_FILE} is not owned by: ${USER}"

    create_dirs_and_files

    write_functions
    write_profile
    write_compats
    write_rc

    mv "${_RC_TMP}" "${_RC_FILE}"
    sync "$@"

    gnu_completions
  fi

  if $hook; then
    echo "${_RC_FILE}"
  elif [ "${function-}" ]; then
    "${function}" "$@"
  fi

}

main "$@"
